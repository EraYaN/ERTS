%!TEX program = xelatex
%!TEX spellcheck = en_GB
\documentclass[final]{article}
\input{../../.library/preamble.tex}
\input{../../.library/style.tex}
\addbibresource{../../.library/bibliography.bib}
\begin{document}
\section{Implementation}
\label{sec:implementation}

All custom embedded systems side code was written in C++ in stead of C.
Note that existing code like drivers and the software SDK was not rewritten to C++, but rather included as \texttt{extern "C"} to ensure compatibility.

\subsection{Communication}
The communication protocol is based on \SI{20}{\byte} fixed-length packets.
This size was chosen to properly fit into Bluetooth Low Energy frames.
The packet layout is as shown in \cref{fig:packet-format}
Some examples are shown in \cref{fig:packet-examples}.
The provided receive and transmit queues were used for the implementation, with an altered depth of \SI{240}{\byte} to fit an integer amount of \SI{20}{\byte} packets.
The receive function scans the input with a constant moving window for the header bytes, and when found receives the packet and passes it to handle packet.
If the type of packet requires an acknowledgement, the \texttt{ackNumber} field is copied and an acknowledgement packet is sent.

\subsection{System}
The system is built using a continuous loop (\texttt{void busywork()}) that runs as fast as possible.
And a timer that set a flag at \SI{100}{\hertz}, this triggers the \texttt{void tick()} function.
A hardware interrupt triggers the retrieval of the DMP sensor values from the MPU, also at \SI{100}{\hertz}.
This results in a near perfect \SI{100}{\hertz} execution rate of the tick function with a maximum delay of one DMP retrieval latency, as shown in \cref{ssec:module-latency}.
All other interval function are implemented as a division of the main loops frequency, so telemetry runs at \SI{10}{\hertz}, and the blue LED runs at \SI{1}{\hertz}, with dividers of 10 en 100 respectively.

The main function that handles mode changes and checks if they are valid is \texttt{void set\_mode(FlightMode)} where \texttt{FlightMode} is the type of the flight mode parameter.
This function returns depending on the current mode the state of the inputs and/or calibration values whenever or not the mode switch is acceptable.
If it's not, an exception packet is sent.

\subsection{Control}
%TODO[E]: The functions control (and possibily control_fast)

\begin{equation}
out = target_{lift} - P_{height} \cdot (target_{pressure} - current_{pressure})
\label{eq:control-height}
\end{equation}
%target is de setpoint, current is hier dat dus de baro waarde

\begin{equation}
out = P_{yaw} \cdot (target_{yaw} - rate_{yaw})
\label{eq:control-yaw}
\end{equation}
%target is de setpoint (rate), rate is hier dat dus de gyro waarde

\begin{equation}
out = P_1 \cdot (target_{roll,pitch} - current_{roll,pitch}) - P_2 \cdot rate_{roll,pitch}
\label{eq:control-roll-pitch}
\end{equation}
%target is de setpoint, current is hier dat dus de DMP waarde
%rate is de gyro rate (sp,sq)


\subsection{Logging}
All important information is written on a per-event basis, so telemetry data is written when telemetry is sent, sensor data is written when it is retrieved and so on.
The packets are variable length and do not contain a checksum.
The first thing written is a time stamp and then the packet type, this makes sure that parsing the binary back will be possible and straightforward.
When the flash is full the logging automatically disengages, and because the function state is included in the telemetry packet to the PC the PC also knows this.
When the dumping mode is activated the transmit buffer is filler to half, and the packets are put in the buffer as quickly as the transmission allows.
This makes for a quick transmission of the full binary data.

\subsection{Dashboard}
The Dashboard application is written in C\# for ease and speed of development.
Creating a GUI and implementing the threads shown in \cref{ssec:architecture-dashboard} is decidedly easier and more straightforward using the .NET framework than it is using any native toolkit.

The smartphone control feature was implemented as a web application using the \texttt{DeviceOrientationEvent} JavaScript API that enables convenient access to the orientation in pitch, yaw and roll of a handheld device.
The application is served by a simple web server built into the dashboard application.

\begin{figure}[H]
    \begin{subfigure}[b]{0.6\textwidth}
    \centering
        \includegraphics[height=10cm]{resources/dashboard-gui.png}
        \caption{The computer side dashboard UI.}
        \label{fig:pc-dashboard-gui}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.4\textwidth}
    \centering
        \includegraphics[height=10cm]{resources/phone-gui.PNG}
        \caption{The phone control UI.}
        \label{fig:phone-control-gui}
    \end{subfigure}
    \caption{The system UIs.}
    \label{fig:system-guis}
\end{figure}

\section{Division of work}
The authoring tags are written in the header files where possible as required.
Due to the limited nuance allowed in said tags, a quick overview is given in \cref{tab:work-division}.

\begin{table}[H]
    \caption{Coarse division of work during the project}
    \label{tab:work-division}
    \centering
    \begin{tabular}{lp{12cm}}
    \toprule
    Module                   & Notes \\
    \midrule
    ES-side architecture & Provided or tweaked/written by Robin \\
    ES-side control & Robin wrote most of the control code for manual, yaw, full and height control, with Casper taking the mixing of the motors. \\
    ES-side communication & Written in part by Erwin and Robin. Initial translation of C\# classes done by Robin.\\
    ES-side state handling & Initial design by Casper, written by Robin \\
    ES-side logging & Written by Casper \\
    ES-side Log dumping & Initial code by Casper, final finishing touches by Erwin \\
    Other ES-side code & Either provided or tweaked/written by Robin and tweaks by Erwin \\
    \midrule
    PC-side architecture & Written by Erwin \\
    PC-side control & Written by Erwin \\
    PC-side communication & Written by Erwin \\
    PC-side user interface & Written by Erwin, Initial binding design and ViewModel by Robin \\
    PC-side visualization & Written by Erwin \\
    PC-side log dumping & Written by Erwin \\
    PC-side http server & Written by Erwin \\
    Other PC-side modules & Written by Erwin, tweaks by Robin \\
    \midrule
    Phone-side input & Written by Robin, tweaks by Erwin \\
    SDL UI prototype & Written by Robin \\
    Protocol prototypes & Written by Erwin \\
    Flash binary parsing & Written by Erwin \\
    \bottomrule
    \end{tabular}
\end{table}
\end{document}